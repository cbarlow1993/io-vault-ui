/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/v2/chains/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all supported chains
     * @description List supported chains and the supported features
     */
    get: {
      parameters: {
        query?: {
          ecosystem?:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias?:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
          chainId?: number;
          includeTestnets?: 'true' | 'false';
          asV1?: 'true' | 'false';
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/modules/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List available modules */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              modules: {
                /** Format: uuid */
                id: string;
                name: string;
                display_name: string;
                is_active: boolean;
              }[];
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/modules/{moduleId}/roles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List roles for a module */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          moduleId: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              roles: {
                /** Format: uuid */
                id: string;
                name: string;
                display_name: string;
              }[];
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/modules/{moduleId}/actions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List actions for a module */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          moduleId: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              actions: {
                /** Format: uuid */
                id: string;
                name: string;
                display_name: string;
              }[];
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/vaults/{vaultId}/addresses/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List addresses for a vault
     * @description Retrieves a paginated list of addresses for the specified vault. By default, returns both monitored and unmonitored addresses. Use the monitored query parameter to filter by monitoring status.
     */
    get: {
      parameters: {
        query?: {
          cursor?: string;
          limit?: number;
          monitored?: 'true' | 'false';
        };
        header?: never;
        path: {
          vaultId: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              data: ({
                address: string;
                chainAlias: string;
                vaultId: string;
                workspaceId: string;
                derivationPath?: string | null;
                subscriptionId: string | null;
                monitored: boolean;
                /** Format: date-time */
                monitoredAt?: string;
                /** Format: date-time */
                unmonitoredAt?: string;
                /** Format: date-time */
                updatedAt: string;
                alias: string | null;
                lastReconciledBlock: number | null;
              } & {
                [key: string]: unknown;
              })[];
              pagination: {
                nextCursor: string | null;
                hasMore: boolean;
                total?: number;
              };
            };
          };
        };
      };
    };
    put?: never;
    /**
     * Generate address for vault
     * @description Generates an address from the vault curves and saves it to the database. If a derivation path is provided, generates an HD address at that path. Optionally starts monitoring the address for transactions.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          vaultId: string;
        };
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            /** @enum {string} */
            chainAlias:
              | 'arbitrum'
              | 'avalanche-c'
              | 'base'
              | 'bsc'
              | 'eth'
              | 'eth-sepolia'
              | 'fantom'
              | 'optimism'
              | 'polygon'
              | 'bitcoin'
              | 'solana'
              | 'ripple'
              | 'tron';
            derivationPath?: string | null;
            /** @default false */
            monitor?: boolean;
            alias?: string | null;
          };
        };
      };
      responses: {
        /** @description Default Response */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              address: string;
              chainAlias: string;
              vaultId: string;
              workspaceId: string;
              derivationPath?: string | null;
              subscriptionId: string | null;
              monitored: boolean;
              /** Format: date-time */
              monitoredAt?: string;
              /** Format: date-time */
              unmonitoredAt?: string;
              /** Format: date-time */
              updatedAt: string;
              alias: string | null;
              lastReconciledBlock: number | null;
              tokens: {
                contractAddress: string;
                symbol: string;
                decimals?: number;
                hidden?: boolean;
              }[];
            } & {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/vaults/{vaultId}/addresses/ecosystem/{ecosystem}/chain/{chainAlias}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List addresses for a vault and chain
     * @description Retrieves a paginated list of addresses for the specified vault and chain. By default, returns both monitored and unmonitored addresses. Use the monitored query parameter to filter by monitoring status.
     */
    get: {
      parameters: {
        query?: {
          cursor?: string;
          limit?: number;
          monitored?: 'true' | 'false';
        };
        header?: never;
        path: {
          vaultId: string;
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              data: ({
                address: string;
                chainAlias: string;
                vaultId: string;
                workspaceId: string;
                derivationPath?: string | null;
                subscriptionId: string | null;
                monitored: boolean;
                /** Format: date-time */
                monitoredAt?: string;
                /** Format: date-time */
                unmonitoredAt?: string;
                /** Format: date-time */
                updatedAt: string;
                alias: string | null;
                lastReconciledBlock: number | null;
              } & {
                [key: string]: unknown;
              })[];
              pagination: {
                nextCursor: string | null;
                hasMore: boolean;
                total?: number;
              };
            };
          };
        };
      };
    };
    put?: never;
    /**
     * Create address for vault
     * @description Create address for vault. By default, the address will not be monitored for transactions. Set monitor: true in the request body to monitor the address for transactions immediately.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          vaultId: string;
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
        };
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            address: string;
            derivationPath?: string | null;
            /** @default false */
            monitor?: boolean;
            alias?: string | null;
          };
        };
      };
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              address: string;
              chainAlias: string;
              vaultId: string;
              workspaceId: string;
              derivationPath?: string | null;
              subscriptionId: string | null;
              monitored: boolean;
              /** Format: date-time */
              monitoredAt?: string;
              /** Format: date-time */
              unmonitoredAt?: string;
              /** Format: date-time */
              updatedAt: string;
              alias: string | null;
              lastReconciledBlock: number | null;
              tokens: {
                contractAddress: string;
                symbol: string;
                decimals?: number;
                hidden?: boolean;
              }[];
            } & {
              [key: string]: unknown;
            };
          };
        };
        /** @description Default Response */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              address: string;
              chainAlias: string;
              vaultId: string;
              workspaceId: string;
              derivationPath?: string | null;
              subscriptionId: string | null;
              monitored: boolean;
              /** Format: date-time */
              monitoredAt?: string;
              /** Format: date-time */
              unmonitoredAt?: string;
              /** Format: date-time */
              updatedAt: string;
              alias: string | null;
              lastReconciledBlock: number | null;
              tokens: {
                contractAddress: string;
                symbol: string;
                decimals?: number;
                hidden?: boolean;
              }[];
            } & {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/vaults/{vaultId}/addresses/ecosystem/{ecosystem}/chain/{chainAlias}/address/{address}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get registered address
     * @description Retrieves details of an address registered for monitoring in the specified vault.
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          vaultId: string;
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
          address: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              address: string;
              chainAlias: string;
              vaultId: string;
              workspaceId: string;
              derivationPath?: string | null;
              subscriptionId: string | null;
              monitored: boolean;
              /** Format: date-time */
              monitoredAt?: string;
              /** Format: date-time */
              unmonitoredAt?: string;
              /** Format: date-time */
              updatedAt: string;
              alias: string | null;
              lastReconciledBlock: number | null;
              tokens: {
                contractAddress: string;
                symbol: string;
                decimals?: number;
                hidden?: boolean;
              }[];
            } & {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update address
     * @description Updates the hidden assets and/or alias for registered address.
     */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          vaultId: string;
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
          address: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': {
            addToHiddenAssets?: string[];
            removeFromHiddenAssets?: string[];
            alias?: string | null;
          };
        };
      };
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    trace?: never;
  };
  '/v2/vaults/{vaultId}/addresses/ecosystem/{ecosystem}/chain/{chainAlias}/address/{address}/monitoring': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Start monitoring an address for transactions
     * @description Start monitoring an existing address. If the address is already monitored, this operation is idempotent. If the address does not exist, returns 404.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          vaultId: string;
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
          address: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              address: string;
              chainAlias: string;
              vaultId: string;
              workspaceId: string;
              derivationPath?: string | null;
              subscriptionId: string | null;
              monitored: boolean;
              /** Format: date-time */
              monitoredAt?: string;
              /** Format: date-time */
              unmonitoredAt?: string;
              /** Format: date-time */
              updatedAt: string;
              alias: string | null;
              lastReconciledBlock: number | null;
              tokens: {
                contractAddress: string;
                symbol: string;
                decimals?: number;
                hidden?: boolean;
              }[];
            } & {
              [key: string]: unknown;
            };
          };
        };
      };
    };
    /**
     * Stop monitoring an address
     * @description Stop transaction monitoring for an address. The address will be marked as unmonitored but will remain associated with the vault.
     */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          vaultId: string;
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
          address: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/vaults/{vaultId}/addresses/ecosystem/{ecosystem}/chain/{chainAlias}/hd-addresses': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List HD addresses
     * @description Retrieves a paginated list of HD addresses for the specified vault and chain.
     */
    get: {
      parameters: {
        query?: {
          cursor?: string;
          limit?: number;
          monitored?: 'true' | 'false';
        };
        header?: never;
        path: {
          vaultId: string;
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              data: ({
                address: string;
                chainAlias: string;
                vaultId: string;
                workspaceId: string;
                derivationPath?: string | null;
                subscriptionId: string | null;
                monitored: boolean;
                /** Format: date-time */
                monitoredAt?: string;
                /** Format: date-time */
                unmonitoredAt?: string;
                /** Format: date-time */
                updatedAt: string;
                alias: string | null;
                lastReconciledBlock: number | null;
              } & {
                [key: string]: unknown;
              })[];
              pagination: {
                nextCursor: string | null;
                hasMore: boolean;
                total?: number;
              };
            };
          };
        };
      };
    };
    put?: never;
    /**
     * Create HD address
     * @description Create an HD (Hierarchical Deterministic) address for the vault. If no derivation path is provided, the next sequential index will be used automatically.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          vaultId: string;
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': {
            derivationPath?: string;
          };
        };
      };
      responses: {
        /** @description Default Response */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              address: string;
              /** @enum {string} */
              chainAlias:
                | 'arbitrum'
                | 'avalanche-c'
                | 'base'
                | 'bsc'
                | 'eth'
                | 'eth-sepolia'
                | 'fantom'
                | 'optimism'
                | 'polygon'
                | 'bitcoin'
                | 'solana'
                | 'ripple'
                | 'tron';
              vaultId: string;
              derivationPath?: string | null;
              /** @enum {string} */
              ecosystem:
                | 'cosmos'
                | 'evm'
                | 'svm'
                | 'tvm'
                | 'utxo'
                | 'xrp'
                | 'substrate';
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/addresses/ecosystem/{ecosystem}/chain/{chainAlias}/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate address format
     * @description Validates whether an address is correctly formatted for the specified blockchain. Does not verify ownership or existence on-chain.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          ecosystem: string;
          chainAlias: string;
        };
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            address: string;
          };
        };
      };
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              valid: boolean;
              address: string;
              chainAlias: string;
              ecosystem: string;
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/balances/ecosystem/{ecosystem}/chain/{chainAlias}/address/{address}/native': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get native balance for an address
     * @description Retrieves the native token balance (ETH, SOL, BTC, etc.) for a specific address on a given chain. Includes USD value conversion and token metadata.
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
          address: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              balance: string;
              symbol: string;
              name: string | null;
              logo: string | null;
              usdValue: string | null;
              lastUpdated: string;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/balances/ecosystem/{ecosystem}/chain/{chainAlias}/address/{address}/tokens': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get token balances for an address
     * @description Retrieves all token balances (ERC-20, SPL tokens, etc.) for a specific address on a given chain. Hidden tokens are filtered by default unless showHiddenTokens=true is provided.
     */
    get: {
      parameters: {
        query?: {
          cursor?: string;
          limit?: number;
          showHiddenTokens?: 'true' | 'false' | boolean;
          showSpam?: 'true' | 'false' | boolean;
          sortBy?: 'balance' | 'usdValue' | 'symbol';
          sortOrder?: 'asc' | 'desc';
        };
        header?: never;
        path: {
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
          address: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              data: {
                address: string;
                balance: string;
                symbol: string;
                decimals: number;
                name: string | null;
                logo: string | null;
                usdValue: string | null;
                isSpam: boolean;
                userSpamOverride: ('trusted' | 'spam') | null;
                /** @enum {string} */
                effectiveSpamStatus: 'spam' | 'trusted' | 'unknown';
              }[];
              lastUpdated: string;
              pagination: {
                nextCursor: string | null;
                hasMore: boolean;
                total?: number;
              };
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/transactions/ecosystem/{ecosystem}/chain/{chainAlias}/address/{address}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List transactions for an address
     * @description Retrieves a paginated list of transactions for the specified address on the given chain. Requires treasury:view_transactions permission.
     */
    get: {
      parameters: {
        query?: {
          cursor?: string;
          limit?: number;
          sort?: 'asc' | 'desc';
          direction?: string;
          includeTransfers?: string;
        };
        header?: never;
        path: {
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
          address: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              data: {
                id: string;
                chainAlias: string;
                txHash: string;
                blockNumber: string;
                blockHash: string;
                txIndex: number | null;
                fromAddress: string;
                toAddress: string | null;
                value: string;
                fee: string | null;
                /** @enum {string} */
                status: 'success' | 'failed' | 'pending';
                /** Format: date-time */
                timestamp: string;
                classificationType: string | null;
                classificationLabel: string | null;
                /** @enum {string} */
                direction?: 'in' | 'out' | 'neutral';
                /** Format: date-time */
                createdAt: string;
                /** Format: date-time */
                updatedAt: string;
                transfers?: {
                  id: string;
                  /** @enum {string} */
                  transferType: 'native' | 'token';
                  /** @enum {string} */
                  direction: 'in' | 'out';
                  fromAddress: string | null;
                  toAddress: string | null;
                  tokenAddress: string | null;
                  amount: string;
                  formattedAmount: string;
                  displayAmount: string;
                  asset: {
                    name: string;
                    symbol: string;
                    decimals: number;
                    logoUri: string | null;
                    coingeckoId: string | null;
                    isVerified: boolean;
                    isSpam: boolean;
                  };
                }[];
              }[];
              pagination: {
                nextCursor: string | null;
                hasMore: boolean;
                total?: number;
              };
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/transactions/ecosystem/{ecosystem}/chain/{chainAlias}/scan-transaction': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Scan transaction for security threats
     * @description Scans an EVM or SVM transaction for potential security threats using Blockaid.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          ecosystem: 'evm' | 'svm';
          chainAlias:
            | 'abstract'
            | 'arbitrum'
            | 'arbitrum-nova'
            | 'astar'
            | 'avalanche-c'
            | 'base'
            | 'berachain'
            | 'blast'
            | 'bsc'
            | 'celo'
            | 'coqnet'
            | 'cronos'
            | 'degen'
            | 'dfk'
            | 'dfk-testnet'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'flame'
            | 'flow-evm'
            | 'fluent-devnet'
            | 'fraxtal'
            | 'fuse'
            | 'gnosis'
            | 'ink'
            | 'lamina1'
            | 'lightlink'
            | 'linea'
            | 'lukso'
            | 'manta-pacific'
            | 'mantle'
            | 'matchain'
            | 'metal'
            | 'metis'
            | 'mint-sepolia'
            | 'mode'
            | 'monad-testnet'
            | 'moonriver'
            | 'morph'
            | 'morph-holesky-testnet'
            | 'optimism'
            | 'orderly-network'
            | 'perennial'
            | 'plume-devnet'
            | 'polygon'
            | 'polygon-zkevm'
            | 'pulsechain'
            | 'quai'
            | 'rari'
            | 'ronin'
            | 'scroll'
            | 'shimmer-evm'
            | 'sonic'
            | 'sophon-testnet'
            | 'superposition-testnet'
            | 'superseed-sepolia'
            | 'xai'
            | 'xdc'
            | 'zksync-era'
            | 'zora'
            | 'solana'
            | 'solana-testnet';
        };
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            /**
             * @default [
             *       "simulation",
             *       "validation"
             *     ]
             */
            options?: ('validation' | 'simulation')[];
            marshalledHex: string;
            /**
             * @default {
             *       "url": null
             *     }
             */
            metadata?: {
              /** @default null */
              url?: string | null;
            };
            overrides?: {
              evm?: {
                /** @default false */
                simulate_with_estimated_gas?: boolean;
              };
            } | null;
          };
        };
      };
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              scan: {
                [key: string]: unknown;
              };
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/transactions/ecosystem/{ecosystem}/chain/{chainAlias}/address/{address}/transaction/{transactionHash}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get transaction details (v2)
     * @description Retrieves detailed information about a specific transaction from PostgreSQL including classification data, native transfers, and token transfers. Requires treasury:view_transactions permission.
     */
    get: {
      parameters: {
        query?: {
          include?: 'operation' | null;
          type?: null;
        };
        header?: never;
        path: {
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
          address: string;
          transactionHash: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              id: string;
              chainAlias: string;
              txHash: string;
              blockNumber: string;
              blockHash: string;
              txIndex: number | null;
              fromAddress: string;
              toAddress: string | null;
              value: string;
              fee: string | null;
              /** @enum {string} */
              status: 'success' | 'failed' | 'pending';
              /** Format: date-time */
              timestamp: string;
              classificationType: string | null;
              classificationLabel: string | null;
              /** @enum {string} */
              direction?: 'in' | 'out' | 'neutral';
              /** Format: date-time */
              createdAt: string;
              /** Format: date-time */
              updatedAt: string;
              transfers: {
                id: string;
                /** @enum {string} */
                transferType: 'native' | 'token';
                /** @enum {string} */
                direction: 'in' | 'out';
                fromAddress: string | null;
                toAddress: string | null;
                tokenAddress: string | null;
                amount: string;
                formattedAmount: string;
                displayAmount: string;
                asset: {
                  name: string;
                  symbol: string;
                  decimals: number;
                  logoUri: string | null;
                  coingeckoId: string | null;
                  isVerified: boolean;
                  isSpam: boolean;
                };
              }[];
              operationId: string | null;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/vaults/{vaultId}/transactions/ecosystem/{ecosystem}/chain/{chainAlias}/build-native-transaction': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Build native currency transaction
     * @description Builds an unsigned transaction for native currency transfer (ETH, SOL, BTC, etc.). Requires treasury:initiate_transfer permission.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          vaultId: string;
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
        };
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            amount: string;
            to: string;
            derivationPath?: string | null;
            gasPrice?: string | null;
            gasLimit?: string | null;
            data?: string | null;
            nonce?: number | null;
            type?: ('legacy' | 'eip1559') | null;
            maxFeePerGas?: string | null;
            maxPriorityFeePerGas?: string | null;
            nonceAccount?: string;
            feeRate?: number | null;
            memo?: string;
            tag?: string;
          };
        };
      };
      responses: {
        /** @description Default Response */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              marshalledHex: string;
              details: {
                name: string;
                type: string;
                value: string;
              }[];
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/vaults/{vaultId}/transactions/ecosystem/{ecosystem}/chain/{chainAlias}/build-token-transaction': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Build token transaction
     * @description Builds an unsigned transaction for token transfer (ERC20, SPL, TRC20). Requires treasury:initiate_transfer permission.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          vaultId: string;
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
        };
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            amount: string;
            to: string;
            derivationPath?: string | null;
            gasPrice?: string | null;
            gasLimit?: string | null;
            data?: string | null;
            nonce?: number | null;
            type?: ('legacy' | 'eip1559') | null;
            maxFeePerGas?: string | null;
            maxPriorityFeePerGas?: string | null;
            nonceAccount?: string;
            feeRate?: number | null;
            memo?: string;
            tag?: string;
            tokenAddress: string;
            decimals?: number;
          };
        };
      };
      responses: {
        /** @description Default Response */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              marshalledHex: string;
              details: {
                name: string;
                type: string;
                value: string;
              }[];
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/vaults/{vaultId}/transactions/ecosystem/svm/chain/solana/build-durable-nonce-transaction': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Build durable nonce account creation transaction
     * @description Builds a transaction to create a Solana durable nonce account. Requires treasury:initiate_transfer permission.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          vaultId: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': {
            derivationPath: string;
          } | null;
        };
      };
      responses: {
        /** @description Default Response */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              marshalledHex: string;
              details: {
                name: string;
                type: string;
                value: string;
              }[];
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/vaults/{vaultId}/transactions/ecosystem/svm/chain/solana/durable-nonce': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get durable nonce account info
     * @description Retrieves information about the Solana durable nonce account. Requires treasury:initiate_transfer permission.
     */
    get: {
      parameters: {
        query?: {
          derivationPath?: string;
        };
        header?: never;
        path: {
          vaultId: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              nonceAccount: string;
              nonce: string;
              authority: string;
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/vaults/{vaultId}/transactions/ecosystem/{ecosystem}/chain/{chainAlias}/transaction': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create transaction from hex
     * @description Creates a transaction record for signing using a pre-built transaction hex, scoped to a specific ecosystem and chain. Requires treasury:initiate_transfer permission.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          vaultId: string;
          ecosystem:
            | 'cosmos'
            | 'evm'
            | 'svm'
            | 'tvm'
            | 'utxo'
            | 'xrp'
            | 'substrate';
          chainAlias:
            | 'arbitrum'
            | 'avalanche-c'
            | 'base'
            | 'bsc'
            | 'eth'
            | 'eth-sepolia'
            | 'fantom'
            | 'optimism'
            | 'polygon'
            | 'bitcoin'
            | 'solana'
            | 'ripple'
            | 'tron';
        };
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            marshalledHex: string;
            memo?: string | null;
            /** @default true */
            broadcast?: boolean | null;
            expiryTimestamp?: unknown | null;
          };
        };
      };
      responses: {
        /** @description Default Response */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              id: string;
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/reconciliation/addresses/{address}/chain/{chainAlias}/reconcile': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Initiate transaction reconciliation
     * @description Creates a new reconciliation job that compares on-chain transaction data with locally stored records to identify discrepancies, missing transactions, and data integrity issues.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          address: string;
          chainAlias: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': {
            /**
             * @default partial
             * @enum {string}
             */
            mode?: 'full' | 'partial';
            fromBlock?: number;
            toBlock?: number;
            fromTimestamp?: number;
            toTimestamp?: number;
          };
        };
      };
      responses: {
        /** @description Default Response */
        202: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              jobId: string;
              /** @enum {string} */
              status: 'pending' | 'running' | 'paused' | 'completed' | 'failed';
              /** @enum {string} */
              mode: 'full' | 'partial';
              fromBlock: number | null;
              toBlock: number | null;
              createdAt: string;
              address: string;
              chainAlias: string;
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/reconciliation/reconciliation-jobs/{jobId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get reconciliation job details
     * @description Retrieves detailed information about a specific reconciliation job including its status, summary statistics, timing information, and audit log.
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          jobId: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              jobId: string;
              /** @enum {string} */
              status: 'pending' | 'running' | 'paused' | 'completed' | 'failed';
              /** @enum {string} */
              mode: 'full' | 'partial';
              fromBlock: number | null;
              toBlock: number | null;
              finalBlock: number | null;
              address: string;
              chainAlias: string;
              provider: string;
              summary: {
                transactionsProcessed: number;
                transactionsAdded: number;
                transactionsSoftDeleted: number;
                discrepanciesFlagged: number;
                errors: number;
              };
              timing: {
                createdAt: string;
                startedAt: string | null;
                completedAt: string | null;
                durationMs: number | null;
              };
              auditLog: {
                /** @enum {string} */
                action: 'added' | 'soft_deleted' | 'discrepancy' | 'error';
                transactionHash: string;
                beforeSnapshot: {
                  [key: string]: unknown;
                } | null;
                afterSnapshot: {
                  [key: string]: unknown;
                } | null;
                discrepancyFields: string[] | null;
                errorMessage: string | null;
              }[];
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/reconciliation/addresses/{address}/chain/{chainAlias}/reconciliation-jobs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List reconciliation jobs
     * @description Retrieves a paginated list of reconciliation jobs for the specified address on the given chain.
     */
    get: {
      parameters: {
        query?: {
          limit?: number;
          offset?: number;
        };
        header?: never;
        path: {
          address: string;
          chainAlias: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              data: {
                jobId: string;
                /** @enum {string} */
                status:
                  | 'pending'
                  | 'running'
                  | 'paused'
                  | 'completed'
                  | 'failed';
                address: string;
                chainAlias: string;
                createdAt: string;
              }[];
              pagination: {
                total: number;
                limit: number;
                offset: number;
                hasMore: boolean;
              };
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/vaults/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a vault with curves
     * @description Creates a new vault with the specified elliptic curves for HD wallet derivation. Requires treasury:manage_vaults permission.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            id: string;
            workspaceId: string;
            curves: {
              algorithm: string;
              /** @enum {string} */
              curve: 'secp256k1' | 'ed25519';
              publicKey: string;
              xpub?: string;
            }[];
          };
        };
      };
      responses: {
        /** @description Default Response */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              id: string;
              workspaceId: string;
              organisationId: string;
              /** Format: date-time */
              createdAt: string;
              curves: {
                /** Format: uuid */
                id: string;
                algorithm: string;
                /** @enum {string} */
                curve: 'secp256k1' | 'ed25519';
                publicKey: string;
                xpub: string | null;
                /** Format: date-time */
                createdAt: string;
              }[];
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/addresses/{addressId}/tokens/{tokenAddress}/spam-override': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Remove spam override for a token
     * @description Removes the user spam override, resetting the token to use the global classification. Use "native" as tokenAddress for the native token.
     */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          addressId: string;
          tokenAddress: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              tokenAddress: string;
              userOverride: ('trusted' | 'spam') | null;
              updatedAt: string;
            };
          };
        };
        /** @description Default Response */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              error: string;
              message: string;
              details?: {
                code: string;
                message: string;
                path: (string | number)[];
              }[];
            };
          };
        };
        /** @description Default Response */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              error: string;
              message: string;
            };
          };
        };
      };
    };
    options?: never;
    head?: never;
    /**
     * Set spam override for a token
     * @description Marks a token as trusted or spam, overriding the automatic classification. Use "native" as tokenAddress for the native token.
     */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          addressId: string;
          tokenAddress: string;
        };
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            /** @enum {string} */
            override: 'trusted' | 'spam';
          };
        };
      };
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              tokenAddress: string;
              userOverride: ('trusted' | 'spam') | null;
              updatedAt: string;
            };
          };
        };
        /** @description Default Response */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              error: string;
              message: string;
              details?: {
                code: string;
                message: string;
                path: (string | number)[];
              }[];
            };
          };
        };
        /** @description Default Response */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              error: string;
              message: string;
            };
          };
        };
      };
    };
    trace?: never;
  };
  '/v2/addresses/{addressId}/tokens/spam-overrides': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Set multiple spam overrides
     * @description Sets spam overrides for multiple tokens at once (max 100). Tokens not found will be silently skipped. Use "native" as tokenAddress for the native token.
     */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          addressId: string;
        };
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            overrides: {
              tokenAddress: string;
              /** @enum {string} */
              override: 'trusted' | 'spam';
            }[];
          };
        };
      };
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              updated: {
                tokenAddress: string;
                userOverride: ('trusted' | 'spam') | null;
                updatedAt: string;
              }[];
            };
          };
        };
        /** @description Default Response */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              error: string;
              message: string;
              details?: {
                code: string;
                message: string;
                path: (string | number)[];
              }[];
            };
          };
        };
      };
    };
    trace?: never;
  };
  '/v2/workflows/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new transaction workflow
     * @description Creates a new transaction workflow. Requires treasury:initiate_transfer permission.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            /** Format: uuid */
            vaultId: string;
            chainAlias: string;
            marshalledHex: string;
            /** @default false */
            skipReview?: boolean;
          };
        };
      };
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/workflows/{id}/confirm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Confirm transaction review
     * @description Confirms transaction review. Requires treasury:approve_transfer permission.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/workflows/{id}/review': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Review pending transfer
     * @description Reviews a pending transfer workflow. Requires treasury:review_transfer permission.
     */
    put: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/workflows/{id}/approve': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Approve transaction
     * @description Approves a transaction. Requires treasury:approve_transfer permission.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/workflows/{id}/reject': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Reject transaction
     * @description Rejects a transaction. Requires treasury:approve_transfer permission.
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          id: string;
        };
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            reason: string;
          };
        };
      };
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/workflows/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get workflow status
     * @description Gets workflow status. Requires treasury:view_transactions permission.
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/workflows/{id}/history': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get workflow event history
     * @description Gets workflow event history. Requires treasury:view_transactions permission.
     */
    get: {
      parameters: {
        query?: {
          limit?: number;
          cursor?: string;
        };
        header?: never;
        path: {
          id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/webhooks/signature': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Receive signature completion webhook */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            /** Format: uuid */
            workflowId: string;
            requestId: string;
            success: boolean;
            signature?: string;
            error?: string;
          };
        };
      };
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/organisations/{orgId}/users/{userId}/global-role': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /** Assign global role to user */
    put: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          orgId: string;
          userId: string;
        };
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            /** @enum {string} */
            role: 'owner' | 'billing' | 'admin';
          };
        };
      };
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** Format: uuid */
              id: string;
              user_id: string;
              organisation_id: string;
              /** @enum {string} */
              role: 'owner' | 'billing' | 'admin';
              created_at: string;
            };
          };
        };
      };
    };
    post?: never;
    /** Remove global role from user */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          orgId: string;
          userId: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/organisations/{orgId}/users/{userId}/module-roles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Assign module role to user */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          orgId: string;
          userId: string;
        };
        cookie?: never;
      };
      requestBody: {
        content: {
          'application/json': {
            module_id: string;
            role: string;
            resource_scope?: {
              vault_ids?: string[];
            } | null;
          };
        };
      };
      responses: {
        /** @description Default Response */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** Format: uuid */
              id: string;
              user_id: string;
              module: string;
              role: string;
              resource_scope: {
                vault_ids?: string[];
              } | null;
              granted_by: string;
              created_at: string;
            };
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/organisations/{orgId}/users/{userId}/module-roles/{moduleId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /** Remove module role from user */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          orgId: string;
          userId: string;
          moduleId: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/organisations/{orgId}/users/{userId}/roles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get user roles */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          orgId: string;
          userId: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Default Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              user_id: string;
              organisation_id: string;
              global_role: ('owner' | 'billing' | 'admin') | null;
              module_roles: {
                module: string;
                role: string;
                resource_scope: {
                  vault_ids?: string[];
                } | null;
              }[];
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: never;
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
